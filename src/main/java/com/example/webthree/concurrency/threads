线程安全
--------
*原子性：提供了互斥访问，即同一时刻只能有一个线程对其进行操作，Java中【atomic包】和【锁】能保证原子性
锁分为两种：synchronized-依赖JVM
            Lock-jdk提供的代码层面的锁，依赖特殊的CPU指令
synchronized：同步锁
              修饰对象：
                   修饰代码块：大括号括起来的代码，作用于【调用的对象】，被修饰代码称为同步语句块
                   修饰方法：修饰整个方法，作用于【调用对象】，被修饰的方法称为同步方。不能被继承，因为synchronized不属于方法声明的
                             一部分，子类想用需要显示声明
                   修饰静态方法：整个静态方法，作用于【这个类的所有对象】
                   修饰类：synchronized后面括号括起来的所有部分，作用于【这个类的所有对象】
synchronized:不可中断锁，适合竞争不激烈，竞争激烈时性能下降特别快，可读性好
Lock:可中断锁，可用unLock解锁，竞争激烈时能维持常态，多样化同步
Atomic：竞争激烈时能维持常态，比Lock性能好，但是只能同步一个值
--------
*可见性：一个线程对主内存的修改可以及时的被其他线程观察到，JVM提供了synchronized和volatile
synchronized：
JMM关于synchronized的两条规定：
1、线程解锁前，需要把共享变量的值刷新到主内存。
2、线程加锁时，需要清空工作内存中共享变量的值，从而使用共享变量时需要从主内存中重新读取最新的值。
加锁和解锁指的是同一把锁。
volatile:
volatile通过加入内存屏障和禁止重排序优化来实现线程可见性
1.volatile变量写操作时，会插入一条store屏障指令（StoreStore和storeLoad），将本地内存中的共享变量值刷新到主内存；
（该变量发生变化时强制线程刷新到主内存）
2.对volatile变量读操作时，会在读操作前加入一条load屏障指令（LoadLoad和LoadStore），从主内存中读取共享变量。
（线程每次访问变量时都会强制从主内存中读取变量值）
volatile适合场景：对变量的写操作不依赖于当前值，该变量没有包含在具有其他变量的式子中，所以volatile特别适合状态标记量
--------
有序性：
有序性：Java内存模型中，允许编辑器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。
保证有序性：volatile、synchronized、lock
Java内存模型具有先天的有序性，不通过任何手段，就能得到保证的有序性，称为happens-before原则(8条)。
如果两个操作的执行顺序无法从本原则推测出来，虚拟机将可随意地对其进行重排序.
Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。
--------
安全发布对象
发布对象：使一个对象能够被当前范围之外的代码所使用
对象溢出：一种错误的发布，当一个对象还没有构造完成时，就使他被其他线程所见，比如，这个Escape类的构造函数没有执行完，而他的内部类却对这个类的封装实例进行引用。
安全发布对象的四种方法：
1、在静态初始化函数中初始化一个对象的引用
2、将对象的引用保存到volatile类型或者AtomicReference对象中
3、将对象的引用保存到某个正确构造对象的final类型域中
4、将对象的引用保存到一个由锁保护的域中
